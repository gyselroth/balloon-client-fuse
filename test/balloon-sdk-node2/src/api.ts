/**
 * balloon API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
export {localVarRequest};
import http = require('http');
import Promise = require('bluebird');

export const specPath = __dirname+'/../swagger.yml';

let defaultBasePath = 'https://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* ACL rule.
*/
export class AclRule {
    /**
    * The type of the resource.
    */
    'type'?: AclRule.TypeEnum;
    /**
    * ACL rules.
    */
    'id'?: string;
    /**
    * Privilege.
    */
    'privilege'?: AclRule.PrivilegeEnum;
    'role'?: AclRuleRole;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "AclRule.TypeEnum"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "privilege",
            "baseName": "privilege",
            "type": "AclRule.PrivilegeEnum"
        },
        {
            "name": "role",
            "baseName": "role",
            "type": "AclRuleRole"
        }    ];

    static getAttributeTypeMap() {
        return AclRule.attributeTypeMap;
    }
}

export namespace AclRule {
    export enum TypeEnum {
        User = <any> 'user',
        Group = <any> 'group'
    }
    export enum PrivilegeEnum {
        Rw = <any> 'rw',
        W = <any> 'w',
        M = <any> 'm',
            //WP = <any> 'w+',
        D = <any> 'd'
    }
}
/**
* Points to the share owner. If the node is not part of any share this is null.
*/
export class AclRuleRole {
    /**
    * The id of the role resource.
    */
    'id'?: string;
    /**
    * The name of role resource.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AclRuleRole.attributeTypeMap;
    }
}

/**
* Describes the api root.
*/
export class ApiRoot {
    'name'?: string;
    'api'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "api",
            "baseName": "api",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApiRoot.attributeTypeMap;
    }
}

/**
* Master node from which the slave is from.
*/
export class BalloonAppConvertSlaveMaster {
    /**
    * The id of the node.
    */
    'id'?: string;
    /**
    * The name of the node.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BalloonAppConvertSlaveMaster.attributeTypeMap;
    }
}

/**
* The generated slave node. As long as the slave has not yet been created this is null.
*/
export class BalloonAppConvertSlaveSlave {
    /**
    * The id of the node.
    */
    'id'?: string;
    /**
    * The name of the node.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BalloonAppConvertSlaveSlave.attributeTypeMap;
    }
}

/**
* Mail
*/
export class BalloonAppNotfificationMail {
    'receiver'?: Array<string>;
    'subject'?: string;
    'body'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "receiver",
            "baseName": "receiver",
            "type": "Array<string>"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BalloonAppNotfificationMail.attributeTypeMap;
    }
}

/**
* A notification may point to a node. If there is no node given this is null.
*/
export class BalloonAppNotfificationNotificationNode {
    /**
    * The id of the node.
    */
    'id'?: string;
    /**
    * The name of the node.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BalloonAppNotfificationNotificationNode.attributeTypeMap;
    }
}

/**
* Points to the message. If there is no sender (For example the message came from the system itself) this is null.
*/
export class BalloonAppNotfificationNotificationSender {
    /**
    * The id of the sender.
    */
    'id'?: string;
    /**
    * The username of the sender.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BalloonAppNotfificationNotificationSender.attributeTypeMap;
    }
}

/**
* Office document
*/
export class BalloonAppOfficeDocument {
    'loleaflet'?: string;
    'sessions'?: Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loleaflet",
            "baseName": "loleaflet",
            "type": "string"
        },
        {
            "name": "sessions",
            "baseName": "sessions",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return BalloonAppOfficeDocument.attributeTypeMap;
    }
}

/**
* Office session
*/
export class BalloonAppOfficeSession {
    /**
    * Session id
    */
    'id'?: string;
    /**
    * WOPI url
    */
    'wopi_url'?: string;
    /**
    * Access token (time limited)
    */
    'access_token'?: string;
    /**
    * Token life time
    */
    'access_token_ttl'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "wopi_url",
            "baseName": "wopi_url",
            "type": "string"
        },
        {
            "name": "access_token",
            "baseName": "access_token",
            "type": "string"
        },
        {
            "name": "access_token_ttl",
            "baseName": "access_token_ttl",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return BalloonAppOfficeSession.attributeTypeMap;
    }
}

/**
* WOPI document https://wopi.readthedocs.io/projects/wopirest/en/latest/files/CheckFileInfo.html
*/
export class BalloonAppOfficeWopiDocument {
    'BaseFileName'?: string;
    'Size'?: string;
    'Version'?: string;
    'OwnerId'?: string;
    'UserId'?: string;
    'UserFriendlyName'?: string;
    'UserCanWrite'?: boolean;
    'PostMessageOrigin'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "BaseFileName",
            "baseName": "BaseFileName",
            "type": "string"
        },
        {
            "name": "Size",
            "baseName": "Size",
            "type": "string"
        },
        {
            "name": "Version",
            "baseName": "Version",
            "type": "string"
        },
        {
            "name": "OwnerId",
            "baseName": "OwnerId",
            "type": "string"
        },
        {
            "name": "UserId",
            "baseName": "UserId",
            "type": "string"
        },
        {
            "name": "UserFriendlyName",
            "baseName": "UserFriendlyName",
            "type": "string"
        },
        {
            "name": "UserCanWrite",
            "baseName": "UserCanWrite",
            "type": "boolean"
        },
        {
            "name": "PostMessageOrigin",
            "baseName": "PostMessageOrigin",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BalloonAppOfficeWopiDocument.attributeTypeMap;
    }
}

/**
* Chunking upload session.
*/
export class ChunkSession {
    /**
    * The upload session id
    */
    'session'?: string;
    /**
    * Tells how many chunks are left to upload.
    */
    'chunks_left'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "session",
            "baseName": "session",
            "type": "string"
        },
        {
            "name": "chunks_left",
            "baseName": "chunks_left",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ChunkSession.attributeTypeMap;
    }
}

/**
* The delta is a differential feed to get changes since the last delta call.
*/
export class Delta {
    /**
    * If true the client needs to reset its state.
    */
    'reset'?: boolean;
    /**
    * ACL rules.
    */
    'cursor'?: string;
    /**
    * If true the server has more entries and the client must send another request with the latest cursor.
    */
    'has_more'?: boolean;
    'nodes'?: Array<Node>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reset",
            "baseName": "reset",
            "type": "boolean"
        },
        {
            "name": "cursor",
            "baseName": "cursor",
            "type": "string"
        },
        {
            "name": "has_more",
            "baseName": "has_more",
            "type": "boolean"
        },
        {
            "name": "nodes",
            "baseName": "nodes",
            "type": "Array<Node>"
        }    ];

    static getAttributeTypeMap() {
        return Delta.attributeTypeMap;
    }
}

/**
* Event log entry. Each event represents an executed operation on the server.
*/
export class EventLog {
    /**
    * The event id.
    */
    'event'?: string;
    /**
    * ISO 8601 timestamp when the event was created.
    */
    'timestamp'?: string;
    /**
    * The event operation.
    */
    'operation'?: EventLog.OperationEnum;
    'node'?: EventLogNode;
    'parent'?: EventLogParent;
    'share'?: NodeShare;
    'user'?: FileHistoryUser;
    'client'?: EventLogClient;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "event",
            "baseName": "event",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "string"
        },
        {
            "name": "operation",
            "baseName": "operation",
            "type": "EventLog.OperationEnum"
        },
        {
            "name": "node",
            "baseName": "node",
            "type": "EventLogNode"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "EventLogParent"
        },
        {
            "name": "share",
            "baseName": "share",
            "type": "NodeShare"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "FileHistoryUser"
        },
        {
            "name": "client",
            "baseName": "client",
            "type": "EventLogClient"
        }    ];

    static getAttributeTypeMap() {
        return EventLog.attributeTypeMap;
    }
}

export namespace EventLog {
    export enum OperationEnum {
        DeleteCollectionReference = <any> 'deleteCollectionReference',
        DeleteCollectionShare = <any> 'deleteCollectionShare',
        DeleteCollection = <any> 'deleteCollection',
        AddCollection = <any> 'addCollection',
        AddFile = <any> 'addFile',
        AddCollectionShare = <any> 'addCollectionShare',
        AddCollectionReference = <any> 'addCollectionReference',
        UndeleteFile = <any> 'undeleteFile',
        UndeleteCollectionReference = <any> 'undeleteCollectionReference',
        UndeleteCollectionShare = <any> 'undeleteCollectionShare',
        RestoreFile = <any> 'restoreFile',
        RenameFile = <any> 'renameFile',
        RenameCollection = <any> 'renameCollection',
        RenameCollectionShare = <any> 'renameCollectionShare',
        RenameCollectionReference = <any> 'renameCollectionReference',
        CopyFile = <any> 'copyFile',
        CopyCollection = <any> 'copyCollection',
        CopyCollectionShare = <any> 'copyCollectionShare',
        CopyCollectionRFeference = <any> 'copyCollectionRFeference',
        MoveFile = <any> 'moveFile',
        MoveCollection = <any> 'moveCollection',
        MoveCollectionReference = <any> 'moveCollectionReference',
        MoveCollectionShare = <any> 'moveCollectionShare'
    }
}
/**
* Describes the client from which the operation was executed.
*/
export class EventLogClient {
    /**
    * The type of the client.
    */
    'type'?: string;
    /**
    * The client app name.
    */
    'app'?: string;
    /**
    * The version of the client app.
    */
    'v'?: string;
    /**
    * The hostname of the client.
    */
    'hostname'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "app",
            "baseName": "app",
            "type": "string"
        },
        {
            "name": "v",
            "baseName": "v",
            "type": "string"
        },
        {
            "name": "hostname",
            "baseName": "hostname",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EventLogClient.attributeTypeMap;
    }
}

/**
* Resolves to the node involved in the operation.
*/
export class EventLogNode {
    /**
    * The id of the node
    */
    'id'?: string;
    /**
    * The name of the node
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EventLogNode.attributeTypeMap;
    }
}

/**
* Points to the parent collection. If the node is in the root this is null.
*/
export class EventLogParent {
    /**
    * The id of the parent collection
    */
    'id'?: string;
    /**
    * The name of the parent collection
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EventLogParent.attributeTypeMap;
    }
}

/**
* File history.
*/
export class FileHistory {
    /**
    * The version number.
    */
    'version'?: number;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Type of change.
    */
    'type'?: number;
    'user'?: FileHistoryUser;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "number"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "FileHistoryUser"
        }    ];

    static getAttributeTypeMap() {
        return FileHistory.attributeTypeMap;
    }
}

/**
* Resolves to user who executed the operation.
*/
export class FileHistoryUser {
    /**
    * The id of the share owner.
    */
    'id'?: string;
    /**
    * The username of the share owner.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FileHistoryUser.attributeTypeMap;
    }
}

/**
* A JSON Patch according rfc6902.
*/
export class JsonPatch {
    'op'?: string;
    'path'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "op",
            "baseName": "op",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return JsonPatch.attributeTypeMap;
    }
}

export class Link {
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Link.attributeTypeMap;
    }
}

/**
* Contains resource links (URL) to other resources.
*/
export class Links {
    'self'?: Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        }    ];

    static getAttributeTypeMap() {
        return Links.attributeTypeMap;
    }
}

export class List {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return List.attributeTypeMap;
    }
}

export class ListLinks {
    'self'?: Link;
    'prev'?: Link;
    'next'?: Link;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "prev",
            "baseName": "prev",
            "type": "Link"
        },
        {
            "name": "next",
            "baseName": "next",
            "type": "Link"
        }    ];

    static getAttributeTypeMap() {
        return ListLinks.attributeTypeMap;
    }
}

/**
* Node meta data.
*/
export class NodeMeta {
    /**
    * Node tags. Tags can be freely choosen.
    */
    'tags'?: Array<string>;
    /**
    * Author.
    */
    'author'?: string;
    /**
    * Content license.
    */
    'license'?: string;
    /**
    * A color tag.
    */
    'color'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "author",
            "baseName": "author",
            "type": "string"
        },
        {
            "name": "license",
            "baseName": "license",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NodeMeta.attributeTypeMap;
    }
}

/**
* Points to the parent collection. If the nodes is in the root this is null.
*/
export class NodeParent {
    /**
    * The id of the parent collection
    */
    'id'?: string;
    /**
    * The name of the parent collection
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NodeParent.attributeTypeMap;
    }
}

/**
* Points to the shared node (or share reference). If the node is not part of any share this is null.
*/
export class NodeShare {
    /**
    * The id of the share collection. If the share is a reference (incoming share) it will point to the share reference and not the id of the shared collection itself.
    */
    'id'?: string;
    /**
    * The name of the share (or share reference).
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NodeShare.attributeTypeMap;
    }
}

/**
* Points to the share owner. If the node is not part of any share this is null.
*/
export class NodeShareowner {
    /**
    * The id of the share owner.
    */
    'id'?: string;
    /**
    * The username of the share owner.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NodeShareowner.attributeTypeMap;
    }
}

export class Resource {
    '_links'?: Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Resource.attributeTypeMap;
    }
}

/**
* Node share.
*/
export class Share {
    /**
    * The name of the share. By default the name of the node.
    */
    'share_name'?: string;
    /**
    * ACL rules.
    */
    'acl'?: Array<AclRule>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "share_name",
            "baseName": "share_name",
            "type": "string"
        },
        {
            "name": "acl",
            "baseName": "acl",
            "type": "Array<AclRule>"
        }    ];

    static getAttributeTypeMap() {
        return Share.attributeTypeMap;
    }
}

/**
* Request node fiel statistics.
*/
export class UserNodeAttributeSummary extends null<String, Array> {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(UserNodeAttributeSummary.attributeTypeMap);
    }
}

/**
* A convert slave
*/
export class BalloonAppConvertSlave {
    '_links'?: Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * Slave format.
    */
    'format'?: string;
    'master'?: BalloonAppConvertSlaveMaster;
    'slave'?: BalloonAppConvertSlaveSlave;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "string"
        },
        {
            "name": "master",
            "baseName": "master",
            "type": "BalloonAppConvertSlaveMaster"
        },
        {
            "name": "slave",
            "baseName": "slave",
            "type": "BalloonAppConvertSlaveSlave"
        }    ];

    static getAttributeTypeMap() {
        return BalloonAppConvertSlave.attributeTypeMap;
    }
}

/**
* A list of convert slaves.
*/
export class BalloonAppConvertSlaves {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<BalloonAppConvertSlave>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<BalloonAppConvertSlave>"
        }    ];

    static getAttributeTypeMap() {
        return BalloonAppConvertSlaves.attributeTypeMap;
    }
}

/**
* A notification
*/
export class BalloonAppNotfificationNotification {
    '_links'?: Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * Notification locale. A locale contains a static message which is of a given locale.
    */
    'locale'?: string;
    /**
    * Subject.
    */
    'subject'?: string;
    /**
    * Message.
    */
    'message'?: string;
    'sender'?: BalloonAppNotfificationNotificationSender;
    'node'?: BalloonAppNotfificationNotificationNode;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "sender",
            "baseName": "sender",
            "type": "BalloonAppNotfificationNotificationSender"
        },
        {
            "name": "node",
            "baseName": "node",
            "type": "BalloonAppNotfificationNotificationNode"
        }    ];

    static getAttributeTypeMap() {
        return BalloonAppNotfificationNotification.attributeTypeMap;
    }
}

/**
* A list of notifications.
*/
export class BalloonAppNotfificationNotifications {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<BalloonAppNotfificationNotification>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<BalloonAppNotfificationNotification>"
        }    ];

    static getAttributeTypeMap() {
        return BalloonAppNotfificationNotifications.attributeTypeMap;
    }
}

/**
* A list of collections.
*/
export class Collections {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Collection>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Collection>"
        }    ];

    static getAttributeTypeMap() {
        return Collections.attributeTypeMap;
    }
}

/**
* A list of events.
*/
export class EventLogs {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<EventLog>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<EventLog>"
        }    ];

    static getAttributeTypeMap() {
        return EventLogs.attributeTypeMap;
    }
}

/**
* A list of files.
*/
export class Files {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return Files.attributeTypeMap;
    }
}

/**
* A group contains user resources.
*/
export class Group {
    '_links'?: Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Group name.
    */
    'name'?: string;
    /**
    * User namespace.
    */
    'namespace'?: string;
    /**
    * Array of user id's.
    */
    'member'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "string"
        },
        {
            "name": "member",
            "baseName": "member",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Group.attributeTypeMap;
    }
}

/**
* A list of groups.
*/
export class Groups {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Group>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Group>"
        }    ];

    static getAttributeTypeMap() {
        return Groups.attributeTypeMap;
    }
}

/**
* A Node.
*/
export class Node {
    '_links'?: Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Node name.
    */
    'name'?: string;
    /**
    * Mimetype.
    */
    'mime'?: string;
    /**
    * Readonly only affects the content of the node but not metadata.
    */
    'readonly'?: boolean;
    /**
    * If node is of type Collection this flag is true.
    */
    'directory'?: boolean;
    'meta'?: NodeMeta;
    /**
    * The size in bytes. If the node is of type collection the size is the number of child nodes.
    */
    'size'?: number;
    /**
    * The path abstraction of the node.
    */
    'path'?: string;
    /**
    * Access level.
    */
    'access'?: Node.AccessEnum;
    'parent'?: NodeParent;
    'share'?: NodeShare;
    'shareowner'?: NodeShareowner;
    /**
    * Is true if the user has an active subscription on this node.
    */
    'subscription'?: boolean;
    /**
    * Subscription excludes actions from the subscribed user itself.
    */
    'subscription_exclude_me'?: boolean;
    /**
    * Is true if the node has a protected public sharelink.
    */
    'sharelink_has_password'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "mime",
            "baseName": "mime",
            "type": "string"
        },
        {
            "name": "readonly",
            "baseName": "readonly",
            "type": "boolean"
        },
        {
            "name": "directory",
            "baseName": "directory",
            "type": "boolean"
        },
        {
            "name": "meta",
            "baseName": "meta",
            "type": "NodeMeta"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "access",
            "baseName": "access",
            "type": "Node.AccessEnum"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "NodeParent"
        },
        {
            "name": "share",
            "baseName": "share",
            "type": "NodeShare"
        },
        {
            "name": "shareowner",
            "baseName": "shareowner",
            "type": "NodeShareowner"
        },
        {
            "name": "subscription",
            "baseName": "subscription",
            "type": "boolean"
        },
        {
            "name": "subscription_exclude_me",
            "baseName": "subscription_exclude_me",
            "type": "boolean"
        },
        {
            "name": "sharelink_has_password",
            "baseName": "sharelink_has_password",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Node.attributeTypeMap;
    }
}

export namespace Node {
    export enum AccessEnum {
        Rw = <any> 'rw',
        W = <any> 'w',
        M = <any> 'm',
        WP = <any> 'w+'
    }
}
/**
* A list of nodes.
*/
export class Nodes {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<Node>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Node>"
        }    ];

    static getAttributeTypeMap() {
        return Nodes.attributeTypeMap;
    }
}

/**
* A user is used to access the server.
*/
export class User {
    '_links'?: Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Unique username.
    */
    'username'?: string;
    /**
    * Display name (Usuallly same as username).
    */
    'name'?: string;
    /**
    * Admin user flag.
    */
    'admin'?: boolean;
    /**
    * User namespace.
    */
    'namespace'?: string;
    /**
    * User locale.
    */
    'locale'?: string;
    /**
    * Authentication source.
    */
    'auth'?: User.AuthEnum;
    /**
    * Hard quota in bytes (Max. limit of storage usage). Note that external storage is not part of the quota. The default is no limit.
    */
    'hard_quota'?: number;
    /**
    * Soft quota in bytes (Warning of high quota usage). The default is no limit.
    */
    'soft_quota'?: number;
    /**
    * Available storage in bytes. Is -1 if there is no hard_quota.
    */
    'available'?: number;
    /**
    * Used storage in bytes.
    */
    'used'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "admin",
            "baseName": "admin",
            "type": "boolean"
        },
        {
            "name": "namespace",
            "baseName": "namespace",
            "type": "string"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        },
        {
            "name": "auth",
            "baseName": "auth",
            "type": "User.AuthEnum"
        },
        {
            "name": "hard_quota",
            "baseName": "hard_quota",
            "type": "number"
        },
        {
            "name": "soft_quota",
            "baseName": "soft_quota",
            "type": "number"
        },
        {
            "name": "available",
            "baseName": "available",
            "type": "number"
        },
        {
            "name": "used",
            "baseName": "used",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}

export namespace User {
    export enum AuthEnum {
        Internal = <any> 'internal',
        External = <any> 'external'
    }
}
/**
* A list of users.
*/
export class Users {
    /**
    * Holds a list of links rfc1738 to other resources.
    */
    '_links'?: ListLinks;
    /**
    * The resource type, always List.
    */
    'kind'?: string;
    /**
    * Holds the number of items in the current list response.
    */
    'count'?: number;
    /**
    * Holds the number of total available items on the server. Note that a List resource is always paged. You need to traverse with offset and limit to request further resources in the list.
    */
    'total'?: number;
    'data'?: Array<User>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "ListLinks"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<User>"
        }    ];

    static getAttributeTypeMap() {
        return Users.attributeTypeMap;
    }
}

/**
* A collection can hold an unlimited number of child nodes.
*/
export class Collection {
    '_links'?: Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Node name.
    */
    'name'?: string;
    /**
    * Mimetype.
    */
    'mime'?: string;
    /**
    * Readonly only affects the content of the node but not metadata.
    */
    'readonly'?: boolean;
    /**
    * If node is of type Collection this flag is true.
    */
    'directory'?: boolean;
    'meta'?: NodeMeta;
    /**
    * The size in bytes. If the node is of type collection the size is the number of child nodes.
    */
    'size'?: number;
    /**
    * The path abstraction of the node.
    */
    'path'?: string;
    /**
    * Access level.
    */
    'access'?: Collection.AccessEnum;
    'parent'?: NodeParent;
    'share'?: NodeShare;
    'shareowner'?: NodeShareowner;
    /**
    * Is true if the user has an active subscription on this node.
    */
    'subscription'?: boolean;
    /**
    * Subscription excludes actions from the subscribed user itself.
    */
    'subscription_exclude_me'?: boolean;
    /**
    * Is true if the node has a protected public sharelink.
    */
    'sharelink_has_password'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "mime",
            "baseName": "mime",
            "type": "string"
        },
        {
            "name": "readonly",
            "baseName": "readonly",
            "type": "boolean"
        },
        {
            "name": "directory",
            "baseName": "directory",
            "type": "boolean"
        },
        {
            "name": "meta",
            "baseName": "meta",
            "type": "NodeMeta"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "access",
            "baseName": "access",
            "type": "Collection.AccessEnum"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "NodeParent"
        },
        {
            "name": "share",
            "baseName": "share",
            "type": "NodeShare"
        },
        {
            "name": "shareowner",
            "baseName": "shareowner",
            "type": "NodeShareowner"
        },
        {
            "name": "subscription",
            "baseName": "subscription",
            "type": "boolean"
        },
        {
            "name": "subscription_exclude_me",
            "baseName": "subscription_exclude_me",
            "type": "boolean"
        },
        {
            "name": "sharelink_has_password",
            "baseName": "sharelink_has_password",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Collection.attributeTypeMap;
    }
}

export namespace Collection {
    export enum AccessEnum {
        Rw = <any> 'rw',
        W = <any> 'w',
        M = <any> 'm',
        WP = <any> 'w+'
    }
}
/**
* A collection can hold an unlimited number of child nodes.
*/
export class ModelFile {
    '_links'?: Links;
    /**
    * Unique 12-byte resource identifier. Note this is a MongoDB ObjectId. The name is the standard resource identifier, the id only useful to verify that a given resource was completely recreated. An ID is immutable and will be created on the server.
    */
    'id'?: string;
    /**
    * ISO 8601 timestamp when the resource was created.
    */
    'created'?: string;
    /**
    * ISO 8601 timestamp when the resource was changed.
    */
    'changed'?: string;
    /**
    * Node name.
    */
    'name'?: string;
    /**
    * Mimetype.
    */
    'mime'?: string;
    /**
    * Readonly only affects the content of the node but not metadata.
    */
    'readonly'?: boolean;
    /**
    * If node is of type Collection this flag is true.
    */
    'directory'?: boolean;
    'meta'?: NodeMeta;
    /**
    * The size in bytes. If the node is of type collection the size is the number of child nodes.
    */
    'size'?: number;
    /**
    * The path abstraction of the node.
    */
    'path'?: string;
    /**
    * Access level.
    */
    'access'?: ModelFile.AccessEnum;
    'parent'?: NodeParent;
    'share'?: NodeShare;
    'shareowner'?: NodeShareowner;
    /**
    * Is true if the user has an active subscription on this node.
    */
    'subscription'?: boolean;
    /**
    * Subscription excludes actions from the subscribed user itself.
    */
    'subscription_exclude_me'?: boolean;
    /**
    * Is true if the node has a protected public sharelink.
    */
    'sharelink_has_password'?: boolean;
    /**
    * The content version. Does increase if the content gets changed.
    */
    'version'?: number;
    /**
    * MD5 content checksum.
    */
    'hash'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_links",
            "baseName": "_links",
            "type": "Links"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "string"
        },
        {
            "name": "changed",
            "baseName": "changed",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "mime",
            "baseName": "mime",
            "type": "string"
        },
        {
            "name": "readonly",
            "baseName": "readonly",
            "type": "boolean"
        },
        {
            "name": "directory",
            "baseName": "directory",
            "type": "boolean"
        },
        {
            "name": "meta",
            "baseName": "meta",
            "type": "NodeMeta"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "access",
            "baseName": "access",
            "type": "ModelFile.AccessEnum"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "NodeParent"
        },
        {
            "name": "share",
            "baseName": "share",
            "type": "NodeShare"
        },
        {
            "name": "shareowner",
            "baseName": "shareowner",
            "type": "NodeShareowner"
        },
        {
            "name": "subscription",
            "baseName": "subscription",
            "type": "boolean"
        },
        {
            "name": "subscription_exclude_me",
            "baseName": "subscription_exclude_me",
            "type": "boolean"
        },
        {
            "name": "sharelink_has_password",
            "baseName": "sharelink_has_password",
            "type": "boolean"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "hash",
            "baseName": "hash",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ModelFile.attributeTypeMap;
    }
}

export namespace ModelFile {
    export enum AccessEnum {
        Rw = <any> 'rw',
        W = <any> 'w',
        M = <any> 'm',
        WP = <any> 'w+'
    }
}

let enumsMap: {[index: string]: any} = {
        "AclRule.TypeEnum": AclRule.TypeEnum,
        "AclRule.PrivilegeEnum": AclRule.PrivilegeEnum,
        "EventLog.OperationEnum": EventLog.OperationEnum,
        "Node.AccessEnum": Node.AccessEnum,
        "User.AuthEnum": User.AuthEnum,
        "Collection.AccessEnum": Collection.AccessEnum,
        "ModelFile.AccessEnum": ModelFile.AccessEnum,
}

let typeMap: {[index: string]: any} = {
    "AclRule": AclRule,
    "AclRuleRole": AclRuleRole,
    "ApiRoot": ApiRoot,
    "BalloonAppConvertSlaveMaster": BalloonAppConvertSlaveMaster,
    "BalloonAppConvertSlaveSlave": BalloonAppConvertSlaveSlave,
    "BalloonAppNotfificationMail": BalloonAppNotfificationMail,
    "BalloonAppNotfificationNotificationNode": BalloonAppNotfificationNotificationNode,
    "BalloonAppNotfificationNotificationSender": BalloonAppNotfificationNotificationSender,
    "BalloonAppOfficeDocument": BalloonAppOfficeDocument,
    "BalloonAppOfficeSession": BalloonAppOfficeSession,
    "BalloonAppOfficeWopiDocument": BalloonAppOfficeWopiDocument,
    "ChunkSession": ChunkSession,
    "Delta": Delta,
    "EventLog": EventLog,
    "EventLogClient": EventLogClient,
    "EventLogNode": EventLogNode,
    "EventLogParent": EventLogParent,
    "FileHistory": FileHistory,
    "FileHistoryUser": FileHistoryUser,
    "JsonPatch": JsonPatch,
    "Link": Link,
    "Links": Links,
    "List": List,
    "ListLinks": ListLinks,
    "NodeMeta": NodeMeta,
    "NodeParent": NodeParent,
    "NodeShare": NodeShare,
    "NodeShareowner": NodeShareowner,
    "Resource": Resource,
    "Share": Share,
    "UserNodeAttributeSummary": UserNodeAttributeSummary,
    "BalloonAppConvertSlave": BalloonAppConvertSlave,
    "BalloonAppConvertSlaves": BalloonAppConvertSlaves,
    "BalloonAppNotfificationNotification": BalloonAppNotfificationNotification,
    "BalloonAppNotfificationNotifications": BalloonAppNotfificationNotifications,
    "Collections": Collections,
    "EventLogs": EventLogs,
    "Files": Files,
    "Group": Group,
    "Groups": Groups,
    "Node": Node,
    "Nodes": Nodes,
    "User": User,
    "Users": Users,
    "Collection": Collection,
    "ModelFile": ModelFile,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum BallonAppElasticsearchV2ApiApiKeys {
}

export class BallonAppElasticsearchV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BallonAppElasticsearchV2ApiApiKeys, value: string) {
        (this.authentications as any)[BallonAppElasticsearchV2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Extended search query using elasticsearch
     * @param query Elasticsearch query as JSON
     * @param deleted Wherever include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted.
     */
    public queryElasticsearch (query: string, deleted?: number) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling queryElasticsearch.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (deleted !== undefined) {
            localVarQueryParameters['deleted'] = ObjectSerializer.serialize(deleted, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Nodes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Nodes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BallonAppPreviewV2ApiApiKeys {
}

export class BallonAppPreviewV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BallonAppPreviewV2ApiApiKeys, value: string) {
        (this.authentications as any)[BallonAppPreviewV2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get a preview of the files content. The body either contains an encoded string or a jpeg binary.
     * @param file File identifier
     * @param encode Set to base64 to return a jpeg encoded preview as base64, else return it as jpeg binary
     */
    public getPreview (file: string, encode?: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/preview'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling getPreview.');
        }

        if (encode !== undefined) {
            localVarQueryParameters['encode'] = ObjectSerializer.serialize(encode, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BalloonAppConvertV2ApiApiKeys {
}

export class BalloonAppConvertV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BalloonAppConvertV2ApiApiKeys, value: string) {
        (this.authentications as any)[BalloonAppConvertV2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add new convert slave
     * @param file File identifier
     * @param body Add new conversion slave 
     */
    public addSlave (file: string, body: BalloonAppConvertSlave) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/convert/slaves'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling addSlave.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addSlave.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "BalloonAppConvertSlave")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: BalloonAppConvertSlave;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BalloonAppConvertSlave");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete slave
     * @param file File identifier
     * @param slave Slave identifier
     */
    public deleteSlave (file: string, slave: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/convert/slaves/{slave}'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)))
            .replace('{' + 'slave' + '}', encodeURIComponent(String(slave)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling deleteSlave.');
        }

        // verify required parameter 'slave' is not null or undefined
        if (slave === null || slave === undefined) {
            throw new Error('Required parameter slave was null or undefined when calling deleteSlave.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get single slave
     * @param file File identifier
     * @param slave Slave identifier
     */
    public getSlave (file: string, slave: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/convert/slaves/{slave}'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)))
            .replace('{' + 'slave' + '}', encodeURIComponent(String(slave)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling getSlave.');
        }

        // verify required parameter 'slave' is not null or undefined
        if (slave === null || slave === undefined) {
            throw new Error('Required parameter slave was null or undefined when calling getSlave.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: BalloonAppConvertSlave;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BalloonAppConvertSlave");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get existing convert slaves
     * @param file File identifier
     */
    public getSlaves (file: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/convert/slaves'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling getSlaves.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: BalloonAppConvertSlaves;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BalloonAppConvertSlaves");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get supported file formats to convert to (formats do vary between files)
     * @param file File identifier
     */
    public getSupportedFormats (file: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/convert/supported-formats'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling getSupportedFormats.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BalloonAppDesktopClientV2ApiApiKeys {
}

export class BalloonAppDesktopClientV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BalloonAppDesktopClientV2ApiApiKeys, value: string) {
        (this.authentications as any)[BalloonAppDesktopClientV2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Download balloon desktop client
     * @param format Request client foramt (deb, rpm, exe, pkg, zip or a custom format)
     */
    public getDesktopClient (format: 'deb' | 'rpm' | 'exe' | 'pkg' | 'zip') : any {
        const localVarPath = this.basePath + '/api/v2/desktop-clients/{format}/content'
            .replace('{' + 'format' + '}', encodeURIComponent(String(format)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'format' is not null or undefined
        if (format === null || format === undefined) {
            throw new Error('Required parameter format was null or undefined when calling getDesktopClient.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BalloonAppNotificationsV2ApiApiKeys {
}

export class BalloonAppNotificationsV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BalloonAppNotificationsV2ApiApiKeys, value: string) {
        (this.authentications as any)[BalloonAppNotificationsV2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete a notification
     * @param notification Resource identifier
     */
    public deleteNotification (notification: string) : any {
        const localVarPath = this.basePath + '/api/v2/notifications/{notification}'
            .replace('{' + 'notification' + '}', encodeURIComponent(String(notification)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'notification' is not null or undefined
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling deleteNotification.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get my nofitifications
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getMyNotifications (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/notifications';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: BalloonAppNotfificationNotifications;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BalloonAppNotfificationNotifications");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single notification
     * @param notification Resource identifier
     */
    public getNotification (notification: string) : any {
        const localVarPath = this.basePath + '/api/v2/notifications/{notification}'
            .replace('{' + 'notification' + '}', encodeURIComponent(String(notification)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'notification' is not null or undefined
        if (notification === null || notification === undefined) {
            throw new Error('Required parameter notification was null or undefined when calling getNotification.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: BalloonAppNotfificationNotification;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BalloonAppNotfificationNotification");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send notification
     * @param body 
     */
    public postNotification (body?: BalloonAppNotfificationNotification) : any {
        const localVarPath = this.basePath + '/api/v2/notifications';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "BalloonAppNotfificationNotification")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: BalloonAppNotfificationNotification;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BalloonAppNotfificationNotification");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send notification to all users
     * @param body Notification
     */
    public sendBroadcast (body?: BalloonAppNotfificationNotification) : any {
        const localVarPath = this.basePath + '/api/v2/notifications/broadcast';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "BalloonAppNotfificationNotification")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: BalloonAppNotfificationNotification;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BalloonAppNotfificationNotification");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Send mail
     * @param body Mail
     */
    public sendMail (body?: BalloonAppNotfificationMail) : any {
        const localVarPath = this.basePath + '/api/v2/notifications/mail';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "BalloonAppNotfificationMail")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Receive node updates
     * @param node Node identifier
     * @param subscribe If true the subscription is active
     * @param exclude_me Exclude subscription owner (me) from change notifications
     * @param recursive Apply subscription to children (inclusive newly added children)
     */
    public subscribeNode (node: string, subscribe?: boolean, exclude_me?: boolean, recursive?: boolean) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/subscription'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling subscribeNode.');
        }

        if (subscribe !== undefined) {
            localVarQueryParameters['subscribe'] = ObjectSerializer.serialize(subscribe, "boolean");
        }

        if (exclude_me !== undefined) {
            localVarQueryParameters['exclude_me'] = ObjectSerializer.serialize(exclude_me, "boolean");
        }

        if (recursive !== undefined) {
            localVarQueryParameters['recursive'] = ObjectSerializer.serialize(recursive, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Node;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Node");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BalloonAppOfficeV2ApiApiKeys {
}

export class BalloonAppOfficeV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BalloonAppOfficeV2ApiApiKeys, value: string) {
        (this.authentications as any)[BalloonAppOfficeV2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create new document from an existing office document template
     * @param body 
     */
    public createDocument (body: any) : any {
        const localVarPath = this.basePath + '/api/v2/office/documents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createDocument.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "any")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create new session for a document
     * @param id Create new session for a document
     */
    public createSession (id: string) : any {
        const localVarPath = this.basePath + '/api/v2/office/sessions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling createSession.');
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: BalloonAppOfficeSession;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BalloonAppOfficeSession");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a running session. If more members are active in the requested session than only the membership gets removed. The session gets completely removed if only one member exists.
     * @param session The session id to delete 
     */
    public deleteSession (session: string) : any {
        const localVarPath = this.basePath + '/api/v2/office/session/{session}'
            .replace('{' + 'session' + '}', encodeURIComponent(String(session)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'session' is not null or undefined
        if (session === null || session === undefined) {
            throw new Error('Required parameter session was null or undefined when calling deleteSession.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retreive office document
     * @param document Document identifier
     */
    public getDocument (document: string) : any {
        const localVarPath = this.basePath + '/api/v2/office/documents/{document}'
            .replace('{' + 'document' + '}', encodeURIComponent(String(document)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'document' is not null or undefined
        if (document === null || document === undefined) {
            throw new Error('Required parameter document was null or undefined when calling getDocument.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: BalloonAppOfficeDocument;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BalloonAppOfficeDocument");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get document session information including document owner, session user and document size
     * @param id The document id
     * @param access_token An access token to access the document
     */
    public getWopiDocument (id: string, access_token: string) : any {
        const localVarPath = this.basePath + '/api/v2/office/wopi/document';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getWopiDocument.');
        }

        // verify required parameter 'access_token' is not null or undefined
        if (access_token === null || access_token === undefined) {
            throw new Error('Required parameter access_token was null or undefined when calling getWopiDocument.');
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (access_token !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(access_token, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: BalloonAppOfficeWopiDocument;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BalloonAppOfficeWopiDocument");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get document contents
     * @param id The document id 
     * @param access_token An access token to access the document
     */
    public getWopiDocumentContent (id: string, access_token: string) : any {
        const localVarPath = this.basePath + '/api/v2/office/wopi/document/contents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getWopiDocumentContent.');
        }

        // verify required parameter 'access_token' is not null or undefined
        if (access_token === null || access_token === undefined) {
            throw new Error('Required parameter access_token was null or undefined when calling getWopiDocumentContent.');
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (access_token !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(access_token, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Join running session
     * @param session The session id to delete 
     */
    public joinSession (session: string) : any {
        const localVarPath = this.basePath + '/api/v2/office/sessions/{session}/join'
            .replace('{' + 'session' + '}', encodeURIComponent(String(session)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'session' is not null or undefined
        if (session === null || session === undefined) {
            throw new Error('Required parameter session was null or undefined when calling joinSession.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: BalloonAppOfficeSession;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BalloonAppOfficeSession");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Save document contents
     * @param id The document id 
     * @param access_token An access token to access the document
     * @param body Document content
     */
    public updateWopiDocuemntContent (id: string, access_token: string, body?: string) : any {
        const localVarPath = this.basePath + '/api/v2/office/wopi/document/contents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateWopiDocuemntContent.');
        }

        // verify required parameter 'access_token' is not null or undefined
        if (access_token === null || access_token === undefined) {
            throw new Error('Required parameter access_token was null or undefined when calling updateWopiDocuemntContent.');
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (access_token !== undefined) {
            localVarQueryParameters['access_token'] = ObjectSerializer.serialize(access_token, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BalloonAppSharelinkV2ApiApiKeys {
}

export class BalloonAppSharelinkV2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BalloonAppSharelinkV2ApiApiKeys, value: string) {
        (this.authentications as any)[BalloonAppSharelinkV2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a unique sharing link of a node (global accessible): a possible existing link will be deleted if this method will be called.
     * @param node Node identifier
     * @param expiration Expire timestamp as unix timestap. Tells the server when the public link should expire automatically. The default is to never expire.
     * @param password Optionally set a password to protect the public link.
     */
    public createLink (node: string, expiration?: number, password?: string) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/share-link'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling createLink.');
        }

        if (expiration !== undefined) {
            localVarQueryParameters['expiration'] = ObjectSerializer.serialize(expiration, "number");
        }

        if (password !== undefined) {
            localVarQueryParameters['password'] = ObjectSerializer.serialize(password, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Node;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Node");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing sharing link
     * @param node Node identifier
     */
    public deleteLink (node: string) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/share-link'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling deleteLink.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum V2ApiApiKeys {
}

export class V2Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: V2ApiApiKeys, value: string) {
        (this.authentications as any)[V2ApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add new group
     * @param data 
     */
    public addGroup (data?: Group) : any {
        const localVarPath = this.basePath + '/api/v2/groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Group")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add new user
     * @param data 
     */
    public addUser (data?: User) : any {
        const localVarPath = this.basePath + '/api/v2/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "User")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Clone existing node
     * @param node Node identifier
     * @param destid Destination collection, if this is null root is taken
     * @param conflict Conflict resolution
     */
    public cloneNode (node: string, destid?: string, conflict?: number) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/clone'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling cloneNode.');
        }

        if (destid !== undefined) {
            localVarQueryParameters['destid'] = ObjectSerializer.serialize(destid, "string");
        }

        if (conflict !== undefined) {
            localVarQueryParameters['conflict'] = ObjectSerializer.serialize(conflict, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Node;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Node");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new collection
     * @param collection Parent collection
     * @param body 
     */
    public createCollection (collection: string, body: Collection) : any {
        const localVarPath = this.basePath + '/api/v2/collections/{collection}'
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling createCollection.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCollection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Collection")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Collection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Collection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new collection in root
     * @param collection Parent collection
     * @param body 
     */
    public createRootCollection (collection: string, body: Collection) : any {
        const localVarPath = this.basePath + '/api/v2/collections'
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling createRootCollection.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createRootCollection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Collection")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Collection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Collection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete group
     * @param group Resource identifier
     * @param force Per default the group gets disabled, if force is set the group gets removed completely.
     */
    public deleteGroup (group: string, force?: boolean) : any {
        const localVarPath = this.basePath + '/api/v2/groups/{group}'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling deleteGroup.');
        }

        if (force !== undefined) {
            localVarQueryParameters['force'] = ObjectSerializer.serialize(force, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete node
     * @param node Node identifier
     * @param force Force flag need to be set to delete a node from trash (node must have the deleted flag) 
     * @param ignore_flag If both ignore_flag and force_flag were set, the node will be deleted completely 
     * @param at Has to be a valid unix timestamp if so the node will destroy itself at this specified time instead immediatly
     */
    public deleteNode (node: string, force?: boolean, ignore_flag?: boolean, at?: number) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling deleteNode.');
        }

        if (force !== undefined) {
            localVarQueryParameters['force'] = ObjectSerializer.serialize(force, "boolean");
        }

        if (ignore_flag !== undefined) {
            localVarQueryParameters['ignore_flag'] = ObjectSerializer.serialize(ignore_flag, "boolean");
        }

        if (at !== undefined) {
            localVarQueryParameters['at'] = ObjectSerializer.serialize(at, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Does only remove sharing options and transform a share back into a normal collection. There will not be any data loss after this action. All existing references would be removed automatically.
     * @param collection Collection identifier
     */
    public deleteShare (collection: string) : any {
        const localVarPath = this.basePath + '/api/v2/collections/{collection}/share'
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling deleteShare.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete user
     * @param user Resource identifier
     * @param force Per default the user gets disabled, if force is set the user gets removed completely.
     */
    public deleteUser (user: string, force?: boolean) : any {
        const localVarPath = this.basePath + '/api/v2/users/{user}'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteUser.');
        }

        if (force !== undefined) {
            localVarQueryParameters['force'] = ObjectSerializer.serialize(force, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Download node contents. Note that collections are zipped on-the-fly.
     * @param node Node identifier
     * @param Byte_Ranges Read stream from a specific offset/limit in bytes 
     * @param encode Can be set to base64 to encode content as base64.
     * @param download Force download file (Content-Disposition: attachment HTTP header)
     */
    public downloadNode (node: string, Byte_Ranges?: number, encode?: 'base64', download?: boolean) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/content'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling downloadNode.');
        }

        if (encode !== undefined) {
            localVarQueryParameters['encode'] = ObjectSerializer.serialize(encode, "'base64'");
        }

        if (download !== undefined) {
            localVarQueryParameters['download'] = ObjectSerializer.serialize(download, "boolean");
        }

        localVarHeaderParams['Byte-Ranges'] = ObjectSerializer.serialize(Byte_Ranges, "number");

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        //if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        //}

        /*return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });*/
    }
    /**
     * 
     * @summary Get server status
     */
    public getApi () : any {
        const localVarPath = this.basePath + '/api';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ApiRoot;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiRoot");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all children of a collection
     * @param collection Parent collection
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param recursive Include children recursively.
     */
    public getChildren (collection: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, recursive?: boolean) : any {
        const localVarPath = this.basePath + '/api/v2/collections/{collection}/children'
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getChildren.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (recursive !== undefined) {
            localVarQueryParameters['recursive'] = ObjectSerializer.serialize(recursive, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Nodes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Nodes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all collections
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getCollections (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/collections';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Collections;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Collections");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get user object of the current authenticated user
     * @param attributes Filter attributes
     */
    public getCurrentUser (attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v2/users/whoami';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return delete nodes (Excluding sub nodes of deleted collections)
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getDeletedNodes (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/trash';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Nodes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Nodes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delta stream with cursor support.
     * @param limit Limit the number of delta entries, if too low you have to call this endpoint more often since has_more would be true more often 
     * @param attributes Filter attributes, per default not all attributes would be returned
     * @param cursor Set a cursor to rquest next nodes within delta processing 
     */
    public getDelta (limit?: number, attributes?: Array<string>, cursor?: string) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/delta';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (cursor !== undefined) {
            localVarQueryParameters['cursor'] = ObjectSerializer.serialize(cursor, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Delta;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Delta");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get event log containing all operations which are made by the user himself or share members
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getEventLog (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/event-log';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: EventLogs;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventLogs");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a full change history of a file
     * @param file File identifier
     */
    public getFileHistory (file: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/history'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling getFileHistory.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: FileHistory;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FileHistory");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all files
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param deleted Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted  
     */
    public getFiles (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, deleted?: number) : any {
        const localVarPath = this.basePath + '/api/v2/files';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (deleted !== undefined) {
            localVarQueryParameters['deleted'] = ObjectSerializer.serialize(deleted, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Files;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Files");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get single group
     * @param group Resource identifier
     * @param attributes Filter attributes
     */
    public getGroup (group: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v2/groups/{group}'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getGroup.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request all member of a group
     * @param group Resource identifier
     */
    public getGroupMembers (group: string) : any {
        const localVarPath = this.basePath + '/api/v2/groups/{group}/members'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getGroupMembers.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A group is a colletion of users
     * @summary Get groups
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getGroups (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/groups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Groups;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Groups");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Use this method to request the latest cursor if you only need to now if there are changes on the server. This method will not return any other data than the newest cursor. To request a feed with all deltas request /delta.
     */
    public getLastCursor () : any {
        const localVarPath = this.basePath + '/api/v2/nodes/last-cursor';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get single node
     * @param node Node identifier
     * @param attributes Filter attributes
     */
    public getNode (node: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling getNode.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Node;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Node");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get summary of node usage.
     * @param user Resource identifier
     */
    public getNodeAttributeSummary (user: string) : any {
        const localVarPath = this.basePath + '/api/v2/users/{user}/node-attribute-summary'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getNodeAttributeSummary.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: UserNodeAttributeSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserNodeAttributeSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get event log containing all operations which are made by the user himself or share members on a given node
     * @param node Node identifier
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getNodeEventLog (node: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/event-log'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling getNodeEventLog.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: EventLogs;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventLogs");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all nodes
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param deleted Wheter include deleted nodes or not, possible values:  0 Exclude deleted 1 Only deleted 2 Include deleted  
     */
    public getNodes (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, deleted?: number) : any {
        const localVarPath = this.basePath + '/api/v2/nodes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (deleted !== undefined) {
            localVarQueryParameters['deleted'] = ObjectSerializer.serialize(deleted, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Nodes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Nodes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary The hirarchy of all parent nodes is ordered in a single level array beginning with the collection on the highest level.
     * @param node Node identifier
     * @param attributes Filter attributes
     * @param self Include requested collection itself at the end of the list (Will be ignored if the requested node is a file)
     */
    public getParentNodes (node: string, attributes?: Array<string>, self?: boolean) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/parents'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling getParentNodes.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (self !== undefined) {
            localVarQueryParameters['self'] = ObjectSerializer.serialize(self, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Nodes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Nodes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all children of the root collection
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     * @param recursive Include children recursively.
     */
    public getRootChildren (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string, recursive?: boolean) : any {
        const localVarPath = this.basePath + '/api/v2/collections/children';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (recursive !== undefined) {
            localVarQueryParameters['recursive'] = ObjectSerializer.serialize(recursive, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Nodes;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Nodes");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get share acl and share name
     * @param collection Collection identifier
     */
    public getShare (collection: string) : any {
        const localVarPath = this.basePath + '/api/v2/collections/{collection}/share'
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling getShare.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Share;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Share");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get single user
     * @param user Resource identifier
     * @param attributes Filter attributes
     */
    public getUser (user: string, attributes?: Array<string>) : any {
        const localVarPath = this.basePath + '/api/v2/users/{user}'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUser.');
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get user avatar
     * @param user Resource identifier
     */
    public getUserAvatar (user: string) : any {
        const localVarPath = this.basePath + '/api/v2/users/{user}/avatar'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUserAvatar.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request all groups of a user
     * @param user Resource identifier
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getUserGroups (user: string, query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/users/{user}/groups'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUserGroups.');
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Groups;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Groups");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A user is a colletion of users
     * @summary Get users
     * @param query Specify a MongoDB based resource query (https://docs.mongodb.com/manual/tutorial/query-documents) using JSON (For example: {\&quot;name\&quot;: {$regex: &#39;foo.*&#39;}}).
     * @param attributes Filter attributes
     * @param offset Objects offset, per default it starts from 0. You may also request a negative offset which will return results from the end [total - offset].
     * @param limit Objects limit, per default 20 objects will get returned
     * @param sort Specify a MongoDB sort operation (https://docs.mongodb.com/manual/reference/method/cursor.sort/) using JSON (For example: {\&quot;name\&quot;: -1}).
     */
    public getUsers (query?: string, attributes?: Array<string>, offset?: number, limit?: number, sort?: string) : any {
        const localVarPath = this.basePath + '/api/v2/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (attributes !== undefined) {
            localVarQueryParameters['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Array<Users>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Users>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get server status
     */
    public getV2 () : any {
        const localVarPath = this.basePath + '/api/v2';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: ApiRoot;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiRoot");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Move node (Change parent collection), single or multiple ones
     * @param node Node identifier
     * @param destid Destination collection, if this is null root is taken
     * @param conflict Conflict resolution
     */
    public moveNode (node: string, destid?: string, conflict?: number) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/move'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling moveNode.');
        }

        if (destid !== undefined) {
            localVarQueryParameters['destid'] = ObjectSerializer.serialize(destid, "string");
        }

        if (conflict !== undefined) {
            localVarQueryParameters['conflict'] = ObjectSerializer.serialize(conflict, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Node;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Node");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set attributes for group
     * @param group Resource identifier
     * @param body Set attributes for group
     */
    public patchGroup (group: string, body: Group) : any {
        const localVarPath = this.basePath + '/api/v2/groups/{group}'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling patchGroup.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchGroup.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Group")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set attributes for user
     * @param user Resource identifier
     * @param body Set attributes for user
     */
    public patchUser (user: string, body: User) : any {
        const localVarPath = this.basePath + '/api/v2/users/{user}'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling patchUser.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling patchUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "User")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Rollback to a recent version from history. Use the version number from history.
     * @param file File identifier
     */
    public rollbackFile (file: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/{file}/restore'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling rollbackFile.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new share from an existing collection
     * @param collection Collection identifier
     * @param body Create a new share from an existing collection 
     */
    public shareCollection (collection: string, body: Share) : any {
        const localVarPath = this.basePath + '/api/v2/collections/{collection}/share'
            .replace('{' + 'collection' + '}', encodeURIComponent(String(collection)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'collection' is not null or undefined
        if (collection === null || collection === undefined) {
            throw new Error('Required parameter collection was null or undefined when calling shareCollection.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling shareCollection.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Share")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Collection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Collection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Restore deleted group
     * @param group Resource identifier
     */
    public undeleteGroup (group: string) : any {
        const localVarPath = this.basePath + '/api/v2/groups/{group}/undelete'
            .replace('{' + 'group' + '}', encodeURIComponent(String(group)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling undeleteGroup.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Undelete (Restore from trash) a single node or multiple ones.
     * @param node Node identifier
     * @param move If node should also be moved during undelete
     * @param destid If node should also be moved during undelete
     * @param conflict Conflict resolution
     */
    public undeleteNode (node: string, move?: boolean, destid?: string, conflict?: number) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}/undelete'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling undeleteNode.');
        }

        if (move !== undefined) {
            localVarQueryParameters['move'] = ObjectSerializer.serialize(move, "boolean");
        }

        if (destid !== undefined) {
            localVarQueryParameters['destid'] = ObjectSerializer.serialize(destid, "string");
        }

        if (conflict !== undefined) {
            localVarQueryParameters['conflict'] = ObjectSerializer.serialize(conflict, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Node;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Node");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Restore deleted user
     * @param user Resource identifier
     */
    public undeleteUser (user: string) : any {
        const localVarPath = this.basePath + '/api/v2/users/{user}/undelete'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling undeleteUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Change attributes
     * @param node Node identifier
     * @param body Change attributes 
     */
    public updateNode (node: string, body: Node) : any {
        const localVarPath = this.basePath + '/api/v2/nodes/{node}'
            .replace('{' + 'node' + '}', encodeURIComponent(String(node)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling updateNode.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateNode.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Node")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: Node;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Node");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload a file chunk. You have to manually splitt the binary data into multiple chunks and upload them successively! using this method. Once uploading the last chunk, the server will automatically create or update the file node. You may set the parent collection, name and or custom attributes only with the last request to save traffic.
     * @param body File content
     */
    public uploadChunk (body: string) : any {
        const localVarPath = this.basePath + '/api/v2/files/chunk';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling uploadChunk.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload an entire file in one-shot. Use this endpoint only for small files, for bigger files use the chunking endpoint.
     * @param body File content
     */
    public uploadFile (body?: string) : any {
        const localVarPath = this.basePath + '/api/v2/files';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        if(localVarQueryParameters['watch'] && localVarQueryParameters['watch'] === true || localVarQueryParameters['stream'] && localVarQueryParameters['stream'] === true) {
            return localVarRequest(localVarRequestOptions);
        }

        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
